# Set up R in Python ----------------------------------------------------------------------------
import os
os.environ['R_HOME'] = r'C:\Program Files\R\R-3.6.3'
os.environ["PATH"]   = r"C:\Program Files\R\R-3.6.3\bin\x64" + ";" + os.environ["PATH"]
# ----------------------------------------------------------------------------------------------

# Prepare packages -----------------------------------------------------------------------------
from folder import *

import pathlib
import glob

import geopandas as gpd
import pandas as pd
import numpy as np

# Ref: https://stackoverflow.com/questions/55797564/how-to-import-r-packages-in-python
import rpy2
import rpy2.robjects as robjects
import rpy2.robjects.packages as rpackages
from rpy2.robjects import r, pandas2ri
pandas2ri.activate()

import matplotlib.pyplot as plt

from copyFile import copy_geom

from sklearn.preprocessing import MinMaxScaler
# ---------------------------------------------------------------------------------------------



# Variables and parameters below are set up based on Rose codes
# Ref: https://github.com/rosepearson/GeoFabrics/blob/main/src/geofabrics/processor.py

# SETTING UP VARIABLES FROM ROSE CODES --------------------------------------------------------
# Main file paths
cache_path = pathlib.Path(fr"{original_lidar_path}\\no_padding")
flow_path = pathlib.Path(original_lidar_path)

# File names generated by geofabrics
river_characteristics = gpd.read_file(cache_path / "river_characteristics.geojson")
river_bathymetry = gpd.read_file(cache_path / "river_bathymetry.geojson")
channel_name = [
    pathlib.Path(i).stem for i in glob.glob(fr"{cache_path}\\*.geojson") if pathlib.Path(i).stem.startswith("rec_channel")
][0]
channel = gpd.read_file(cache_path / fr"{channel_name}.geojson")
flow_and_friction = pd.read_csv(flow_path / "flow_and_friction.csv.gz")

# Variable names
flow_name = "flow"
friction_name = "mannings_n"

slope_name = "slope_mean_2.0km"
min_z_name = "min_z_centre_unimodal"
width_name = "widths_mean_0.25km"
flat_width_name = "flat_widths_mean_0.25km"
threshold_name = "thresholds_mean_0.25km"

# Match the river characteristics to the REC flow and frictions
# Match each channel midpoint to a nzsegment ID - based on what channel reach is closest
river_characteristics["nzsegment"] = (
        np.ones(len(river_characteristics["widths"]), dtype=float) * np.nan
)
for i, row in river_characteristics.iterrows():
    if row.geometry is not None and not row.geometry.is_empty:
        # Calculate the distance between the point from points of river_characteristics to channel
        distances = channel.distance(river_characteristics.loc[i].geometry)
        # Choose the closest distances and then choose the minimum nzsegment
        river_characteristics.loc[i, ("nzsegment")] = channel[
            distances == distances.min()
            ]["nzsegment"].min()

# Fill in any missing values
river_characteristics["nzsegment"] = (
    river_characteristics["nzsegment"].fillna(method="ffill").fillna(method="bfill")
)
river_characteristics["nzsegment"] = river_characteristics["nzsegment"].astype("int")

# Add the friction and flow values to the widths and slopes
river_characteristics[friction_name] = np.zeros(len(river_characteristics["nzsegment"]), dtype=int)
river_characteristics[flow_name] = np.zeros(len(river_characteristics["nzsegment"]), dtype=int)

for nzsegment in river_characteristics["nzsegment"].unique():
    river_characteristics.loc[
        river_characteristics["nzsegment"] == nzsegment, (friction_name)
    ] = flow_and_friction[flow_and_friction["nzsegment"] == nzsegment]["n"].unique()[0]
    river_characteristics.loc[river_characteristics["nzsegment"] == nzsegment, (flow_name)] = flow_and_friction[
        flow_and_friction["nzsegment"] == nzsegment
        ][flow_name].unique()[0]

# # Ref: https://stackoverflow.com/questions/24511200/index-of-non-nan-values-in-pandas
# https://stackoverflow.com/questions/13413590/how-to-drop-rows-of-pandas-dataframe-whose-value-in-a-certain-column-is
# -nan
# Get indices of nan and notnan rows
index_nan = river_characteristics[river_characteristics.geometry.isna()].index.tolist()
index_notnan = river_characteristics[river_characteristics.geometry.notna()].index.tolist()

# Change river characteristics and river bathymetry
river_characteristics = river_characteristics.drop(index_nan).reset_index(drop=True)
river_bathymetry = river_bathymetry.drop(index_nan).reset_index(drop=True)

# END SETTING UP VARIABLES FROM ROSE CODES ----------------------------------------------------

# Functions below is to calculate depth according Neal et al or Rupp et al as papers below
# Neal: https://doi.org/10.1029/2020WR028301
# Rupp: http://dx.doi.org/10.1016/j.jhydrol.2007.08.024
# For more information about functions: https://github.com/rosepearson/GeoFabrics/blob/main/src/geofabrics/processor.py

# DEPTH CALCULATION FUNCTION ------------------------------------------------------------------------
def calculate_depth(alpha, beta, K_0, slope, width, flow):
    full_bank_depth = ( flow / (K_0 * width * (slope ** beta) ) ) ** (1 / (1 + alpha))
    return full_bank_depth
# END DEPTH CALCULATION FUNCTION --------------------------------------------------------------------------------

# GENERATE ERROR SIMULATIONS ------------------------------------------------------------------------
def get_r_bathypoints(para_name, error):
    """
    @Definition:
                A function to calculate bathymetry points with error
    @References:
                None.
    @Arguments:
                para_name (string):
                                    Name of parameter that needs to simulated
                error (float):
                                    Number to create error
    @Returns:
                para_df, bathy_points/para_error_df (pandas dataframe):
                                    Dataframe that includes original and error of coordinates xy and param
    """

    # Get original parameter
    para_dict ={
        'x': river_characteristics.geometry.x,
        'y': river_characteristics.geometry.y,
        'z': river_characteristics[para_name]
    }
    para_df = pd.DataFrame(data=para_dict)

    # Convert to error
    error_df = para_df.copy(deep=True)
    error_df['z'] = para_df['z'] * error

    # Convert to r dataframe
    bathy_points = pandas2ri.py2rpy_pandasdataframe(error_df)

    return para_df, error_df, bathy_points


# SIMULATIONS FOR PARAMETERS -----------------------------------------------------------------------------------
def generate_parasim(para_name):
    """
    @Definition:
                A function to generate simulations errors of chosen parameter
    @References:
                https://stackoverflow.com/questions/11473206/keyword-error-calling-as-geodata-function-in-geor-with-rpy2/11480562#11480562
                https://pandas.pydata.org/pandas-docs/version/0.19.2/r_interface.html
                https://stackoverflow.com/questions/11561258/r-python-install-packages-on-rpy2https://stackoverflow.com/questions/11561258/r-python-install-packages-on-rpy2
                https://stackoverflow.com/questions/59462337/importing-any-function-from-an-r-package-into-python
                https://rpy2.github.io/doc/v2.9.x/html/introduction.html
                https://www.listendata.com/2020/09/How-to-rename-columns-in-Pandas.html

                https://stackoverflow.com/questions/51501256/plotting-empirical-and-fitted-semivariogram-in-ggplot
                https://stackoverflow.com/questions/3777174/plotting-two-variables-as-lines-using-ggplot2-on-the-same-graph
                https://stackoverflow.com/questions/27852620/using-geom-line-in-a-for-loop

                https://stackoverflow.com/questions/71546726/r-loop-over-linear-regression
                https://stackoverflow.com/questions/12300565/return-multiple-values-from-apply-function-in-r
                https://stackoverflow.com/questions/51723744/r-separate-multiple-columns-into-list
                https://stackoverflow.com/questions/5237557/extract-every-nth-element-of-a-vector
                https://stackoverflow.com/questions/13442461/populating-a-data-frame-in-r-in-a-loop
                https://stackoverflow.com/questions/41683444/check-to-see-if-a-value-is-within-a-range
                https://stackoverflow.com/questions/2370515/how-to-get-row-index-number-in-r
                https://stackoverflow.com/questions/61321934/mutate-all-except-some-columns
                https://www.guru99.com/r-apply-sapply-tapply.html

                https://stackoverflow.com/questions/16194212/how-to-suppress-warnings-globally-in-an-r-script
                https://stackoverflow.com/questions/15589601/print-string-and-variable-contents-on-the-same-line-in-r
                https://stackoverflow.com/questions/45555028/converting-a-max-min-normalized-array-back-to-its-original-scale

                https://stackoverflow.com/questions/71546726/r-loop-over-linear-regression
                https://stackoverflow.com/questions/13442461/populating-a-data-frame-in-r-in-a-loop
                https://www.geeksforgeeks.org/change-column-name-of-a-given-dataframe-in-r/

                # Calculate in pandas dataframe through columns with loop
                https://stackoverflow.com/questions/45383144/subtracting-many-columns-in-a-df-by-one-column-in-another-df
                https://stackoverflow.com/questions/20490274/how-to-reset-index-in-a-pandas-dataframe

                https://stackoverflow.com/questions/51501256/plotting-empirical-and-fitted-semivariogram-in-ggplot
                https://stackoverflow.com/questions/50028496/still-getting-error-in-dev-off-cannot-shut-down-device-1-the-null-device
                https://www.rdocumentation.org/packages/grDevices/versions/3.4.1/topics/png
                https://stackoverflow.com/questions/7144118/how-to-save-a-plot-as-image-on-the-disk
                https://stackoverflow.com/questions/53089219/specify-path-in-write-csv-function

    @Arguments:
                para_name (string):
                                    Name of parameter that needs to simulated
    @Returns:
                sims_df (pandas dataframe):
                                    Dataframe that includes
                                    all simulations of chosen parameter with error
    """
    # Create analysis folder
    bathy_analysis_path = bathy_path + "\\bathy_analyses\\"
    pathlib.Path(f"{bathy_analysis_path}").mkdir(parents=True, exist_ok=True)
    robjects.globalenv['bathy_analysis_path'] = bathy_analysis_path

    if para_name == width_name:
        # Get pandas dataframes of original para and bathy_points
        para_df, ori_error_df, bathy_points = get_r_bathypoints(para_name, .1)

        # Write out csv bathy_points
        ori_error_df.to_csv(fr"{bathy_analysis_path}\bathy_points_{para_name}.csv", index=False)

        # Attach r dataframe into r variable
        robjects.globalenv['bathy_points'] = bathy_points

        # Get simulations
        z_sim = robjects.r('''
            # Import all necessary libraries
            library(sp)
            library(gstat)
            library(ggplot2)
            library(tidyverse)
            library(dplyr)
            library(zeallot)
            library(tibble)
            library(foreach)
            library(doParallel)
            library(reshape2)
            
            # DATA PREPARATION ------------------------------------------                        
            # Convert data to spatial data
            bathy_sdf <- sp::SpatialPointsDataFrame(coords=cbind(bathy_points$x, bathy_points$y), 
                                                    data=bathy_points, 
                                                    proj4string=sp::CRS(projargs="+init=epsg:2193"))
            
            # Create new data
            newbathy_df <- data.frame(bathy_points$x, bathy_points$y)
            colnames(newbathy_df)[1] <- 'x'
            colnames(newbathy_df)[2] <- 'y'
            newbathy_sdf <- sp::SpatialPointsDataFrame(coords=cbind(newbathy_df$x, newbathy_df$y), 
                                                       data=newbathy_df, 
                                                       proj4string=sp::CRS(projargs="+init=epsg:2193"))
            
            # EMPIRICAL VARIOGRAM ----------------------------------------
            # Calculate empirical variogram
            var <- gstat::variogram(object=z~1, locations=bathy_sdf)
            # fit_var <- gstat::fit.variogram(
            #     object=gstat::variogram(object=z~1, locations=bathy_sdf),
            #     fit.sills=F, fit.ranges=F,
            #     model=gstat::vgm(nugget=0.0000001, 'Gau', psill=0.5, range=3654.585)
            # )
            
            fit_var <- gstat::fit.variogram(
                  object=gstat::variogram(object=z~1, locations=bathy_sdf),
                  fit.sills=F, fit.ranges=F,
                  model=gstat::vgm(nugget=0.0000001, 'Gau', psill=0.5, range=3654.57)
            )
            
            
            # Plot variogram and save
            plot_ori_path = paste(bathy_analysis_path, "width_ori_variogram.png", sep = '') # Saving path
            ori_pred = variogramLine(fit_var, maxdist = max(var$dist))  # Generate variogramline for plotting
            plot_ori_var = ggplot(var, aes(x = dist, y = gamma)) +
                                geom_point() +
                                geom_line(data = ori_pred) # Plot using ggplot
            ggsave(plot_ori_path, plot=plot_ori_var) # Save plot
            
            # FUNCTIONS FOR SIMULATIONS -----------------------------------
            # Function to create new spatial dataframe
            spatial_df <- function(points){
              # Convert data as necessary
              sdf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), 
                                                data=points, 
                                                proj4string=sp::CRS(projargs="+init=epsg:2193"))
              # Return
              return(sdf)
            }
        
            # Function to generate unconditional simulations 
            # for a specific setseed_id using a calculated variogram
            sims_generation <- function(newsdf, fvar, points, setseed_id, loop_sim){
              # Set seed
              set.seed(setseed_id)
        
              # Create simulations for that set.seed (z.s means simulations of z)
              z.s <- gstat::krige(z~1, loc=NULL, newdata=newsdf, model=fvar, nmax=100, nsim=loop_sim, beta=0, dummy=T)
        
              # Convert spatial dataframe to dataframe
              z.s.df <- as.data.frame(z.s)
        
              # Rename coordinates
              z.s.df <- z.s.df %>%
                rename(x = coords.x1, y = coords.x2)
        
              # Add original z column
              z.s.df <- add_column(z.s.df, z=points$z, .after=2)
        
              # Change columns' names      
              colnames(z.s.df)[4:length(z.s.df)] <- paste0('sim', seq(1, length(z.s.df)-3))
              
              # Return
              return(z.s.df)
            }
            
            # Function to SELECT simulations in a specific set.seed
            # that are highly simular to the empirical variogram
            selected_sims_oneseed <- function(newsdf, fvar, points, setseed_id, loop_sim,
                                              lower_range, upper_range,
                                              lower_sill, upper_sill,
                                              lower_nugget, upper_nugget){
        
              # Create simulations
              z.s.df <- sims_generation(newsdf, fvar, points, setseed_id, loop_sim)
        
              # Convert to spatial dataframe
              z.s.spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), 
                                                    data=z.s.df, 
                                                    proj4string=sp::CRS(projargs="+init=epsg:2193"))
        
              # Name of columns
              sim_name <- colnames(z.s.df)[4:length(colnames(z.s.df))]
        
        
              # Create fitvar for simulations of a specific set.seed
              fitvar_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))
        
                # Calculate fitted variogram
                fit_varr <- gstat::fit.variogram(object=gstat::variogram(object=form, locations=z.s.spf), model=gstat::vgm('Gau'))
        
                # Return list of range, sill, and nugget
                return(list(fit_varr$range[2], fit_varr$psill[2], fit_varr$psill[1]))
                })
        
              # Add to dataframe
              # Create dimensions by using matrix function
              z.fitvar.m = matrix(ncol=3, nrow=loop_sim)
              # Create fitvar dataframe
              z.fitvar.df <- as.data.frame(z.fitvar.m)
              # Create dataframe column names
              colnames(z.fitvar.df) <- c('range', 'sill', 'nugget')
              # Assign values into each columns
              z.fitvar.df$range <- unlist(fitvar_list)[seq(1, loop_sim*3, 3)]
              z.fitvar.df$sill <- unlist(fitvar_list)[seq(2, loop_sim*3, 3)]
              z.fitvar.df$nugget <- unlist(fitvar_list)[seq(3, loop_sim*3, 3)]
        

              # Create another column named OK
              # to check conditions for range, sill, and nugget
              z.fitvar.ok <- z.fitvar.df %>%
                                mutate(OK = (z.fitvar.df$range>=lower_range)&(z.fitvar.df$range<=upper_range)
                                            &(z.fitvar.df$sill>=lower_sill)&(z.fitvar.df$sill<=upper_sill))
        
              # Get indices of chosen simulations
              ind.z = which(z.fitvar.ok$OK == TRUE) + 3
        
              # Get lists of chosen simulations
              chosen.sims = lapply(names(z.s.df)[ind.z], function(x) z.s.df[[x]])
            }
        
            # Function to select simulations through many set.seeds
            selected_sims_multiseeds <- function(newsdf, fvar, points, num.seeds, loop_sim, 
                                                 range_max_rate, sill_max_rate, nugget_max_rate){
                                                
              #setup parallel backend to use many processors
              cores= detectCores()
              cl <- makeCluster(cores[1]-1) #not to overload computer
              registerDoParallel(cl)
        
              # Range
              upper_range = fvar$range[2]*range_max_rate
              lower_range = fvar$range[2]*(2-range_max_rate)
        
              # # Sill
              # upper_sill = fvar$psill[2]*sill_max_rate
              # lower_sill = fvar$psill[2]*(2-sill_max_rate)
              
              upper_sill = .51
              lower_sill = .5*.9
        
              # Nugget
              upper_nugget = fvar$psill[1]*nugget_max_rate
              lower_nugget = fvar$psill[1]*(2-nugget_max_rate)
        
              # Parallel
              sim_lists <- foreach(i=1:num.seeds, .combine=append, 
                                   .packages=c('gstat', 'sp', 'tidyverse', 'dplyr', 'tibble'),
                                   .export=c("selected_sims_oneseed", "sims_generation")) %dopar% {
        
                # Create a list of each time simulating
                sim_eachlist <- selected_sims_oneseed(newsdf, fvar, points, i, loop_sim,
                                                      lower_range, upper_range,
                                                      lower_sill, upper_sill,
                                                      lower_nugget, upper_nugget)
        
                # Return the list of simulations
                sim_eachlist
              }
        
              return(sim_lists)
            }
            
            # RUN FUNCTIONS -------------------------------------------------------
            # bathy_sims <- selected_sims_multiseeds(newbathy_sdf, fit_var, bathy_points, 1, 1000,
            #                                        1.1, 1.1, 1.1)
            bathy_sims <- selected_sims_multiseeds(newbathy_sdf, fit_var, bathy_points, 1, 10000,
                                                   1.1, 1.1, 1.1)
            
            
            # TRANSFORM DATA BACK -------------------------------------------------
            # Convert list of chosen sims to matrix
            bathy_sims_m = matrix(unlist(bathy_sims), 
                                  ncol=length(bathy_sims), 
                                  nrow=dim(bathy_points)[1])
                                  
            # Convert matrix to dataframe
            bathy_sims_convert = as.data.frame(bathy_sims_m)
            newbathy_sims_convert = as.data.frame(bathy_sims_m)

            # Rename
            colnames(bathy_sims_convert) <- paste0('sim', seq(1, length(bathy_sims)))
            colnames(newbathy_sims_convert) <- paste0('sim', seq(1, length(bathy_sims)))
            
            # Select columns
            bathy_sims_df <- bathy_sims_convert
            newbathy_sims_df <- bathy_sims_convert
            
            # PLOT VARIOGRAMS --------------------------------------------------
            # Function to generate list of var
            var_generation <- function(points, df){
              # Convert to spatial dataframe
              spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), data=df, proj4string=sp::CRS(projargs="+init=epsg:2193"))

              # Name of columns
              sim_name <- colnames(df)

              # Create fitvar for simulations of this seed
              var_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))

                varr <- gstat::variogram(object=form, locations=spf)

                # Return list of range, sill, and nugget
                return(varr)
                })
              var_list
            }

            # Function to generate fit_var
            fit_generation <- function(points, df){

              # Convert to spatial dataframe
              spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), data=df, proj4string=sp::CRS(projargs="+init=epsg:2193"))

              # Name of columns
              sim_name <- colnames(df)

              # Create fitvar for simulations of this seed
              fitvar_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))

                # Calculate fitted variogram
                fit_varr <- gstat::fit.variogram(object=gstat::variogram(object=form, locations=spf), model=gstat::vgm('Gau'))

                # Return list of range, sill, and nugget
                return(fit_varr)
                })
              fitvar_list
            }

            # Plot-many-variograms-in-one-graph function
            # Ref: https://stackoverflow.com/questions/59545834/highlighting-one-of-my-line-graphs-in-ggplot
            plot_variogram <- function(v, f, ori_v, ori_f){
              # Plot many variograms
              p <- ggplot()
              for (i in 1:length(f)){
                preds = gstat::variogramLine(f[[i]], maxdist=max(v[[i]]$dist))
                p <- p + geom_line(data=preds, aes(x=dist, y=gamma))
              }
              # Plot main variogram
              main_preds = gstat::variogramLine(ori_f, maxdist=max(ori_v$dist))
              p + geom_line(data=main_preds, aes(x=dist, y=gamma), color='red', size=1.5)
            }

            # Calculate lists of var and fit_var
            v_list <- var_generation(bathy_points, bathy_sims_df)
            f_list <- fit_generation(bathy_points, bathy_sims_df)

            # Plot and save plot to png
            plot_sim_path = paste(bathy_analysis_path, "width_sim_variogram.png", sep = '')
            plot_sim_var = plot_variogram(v_list, f_list, var, fit_var)
            ggsave(plot_sim_path, plot=plot_sim_var)
            
            
            # PLOT SIMULATED LINES --------------------------------------------------------
            # Get distance column
            copy_bathy_sims_df <- as.data.frame(bathy_sims_df)
            copy_bathy_sims_df$distance <- seq(0, by = 10, length.out = nrow(copy_bathy_sims_df))
            
            # Plot lines
            data_melt <- reshape2::melt(copy_bathy_sims_df, id='distance')
            plot_lines_path = paste(bathy_analysis_path, "width_simulated_lines.png", sep = '')
            gfg_plot <- ggplot(data_melt,            
                               aes(x = distance,
                                   y = value,
                                   color=variable)) +  geom_line()
            
            ggsave(plot_lines_path, plot=gfg_plot)
            
            
            # PLOT ERROR AREA -----------------------------------------------------------
            # Calculate mean and standard deviation for each row
            data_mean <- apply(newbathy_sims_df, 1, mean)
            data_sd <- apply(newbathy_sims_df, 1, sd)
            
            # Create dataframe includes distance, mean, and sd
            data_error <- data.frame(
              distance=copy_bathy_sims_df$distance,
              mean=data_mean,
              sd=data_sd
            )
            
            # Plot error
            plot_error_path = paste(bathy_analysis_path, "width_unit_error_area.png", sep = '')
            red2 <- adjustcolor("red", alpha.f=0.25)
            error_plot = f <- ggplot(
                data_error, aes(x = distance, y = mean, ymin = mean-sd, ymax = mean+sd)
                ) + xlab('distance') + ylab('Mean +/- sd') + geom_errorbar(width = 0.2, col=red2) + geom_point(size = 1.5, col='red')
            ggsave(plot_error_path, plot=error_plot)
            
            # RETURN NECESSARY DATAFRAME TO PYTHON -----------------------------------
            newbathy_sims_df
        ''')

    elif para_name == slope_name:
        # Get pandas dataframes of original para and bathy_points
        para_df, ori_error_df, bathy_points = get_r_bathypoints(para_name, .1)

        # Write out csv bathy_points
        ori_error_df.to_csv(fr"{bathy_analysis_path}\bathy_points_{para_name}.csv", index=False)

        # Attach r dataframe into r variable
        robjects.globalenv['bathy_points'] = bathy_points

        # Get simulations
        z_sim = robjects.r('''
            # Import all necessary libraries
            library(sp)
            library(gstat)
            library(ggplot2)
            library(tidyverse)
            library(dplyr)
            library(zeallot)
            library(tibble)
            library(foreach)
            library(doParallel)

            # DATA PREPARATION ------------------------------------------
            # Convert data to spatial data
            bathy_sdf <- sp::SpatialPointsDataFrame(coords=cbind(bathy_points$x, bathy_points$y), 
                                                    data=bathy_points, 
                                                    proj4string=sp::CRS(projargs="+init=epsg:2193"))

            # Create new data
            newbathy_df <- data.frame(bathy_points$x, bathy_points$y)
            colnames(newbathy_df)[1] <- 'x'
            colnames(newbathy_df)[2] <- 'y'
            newbathy_sdf <- sp::SpatialPointsDataFrame(coords=cbind(newbathy_df$x, newbathy_df$y), 
                                                       data=newbathy_df, 
                                                       proj4string=sp::CRS(projargs="+init=epsg:2193"))

            # EMPIRICAL VARIOGRAM ----------------------------------------
            # Calculate empirical variogram
            var <- gstat::variogram(object=z~1, locations=bathy_sdf)
            fit_var <- gstat::fit.variogram(
                object=var,
                fit.sills=F, fit.ranges=F,
                model=gstat::vgm(nugget=0.0000001, 'Gau', psill=0.5, range=2950)
            )
            # Plot variogram and save
            plot_ori_path = paste(bathy_analysis_path, "slope_ori_variogram.png", sep = '') # Saving path
            ori_pred = variogramLine(fit_var, maxdist = max(var$dist))  # Generate variogramline for plotting
            plot_ori_var = ggplot(var, aes(x = dist, y = gamma)) +
                                geom_point() +
                                geom_line(data = ori_pred) # Plot using ggplot
            ggsave(plot_ori_path, plot=plot_ori_var) # Save plot

            # FUNCTIONS FOR SIMULATIONS -----------------------------------
            # Function to create new spatial dataframe
            spatial_df <- function(points){
              # Convert data as necessary
              sdf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), 
                                                data=points, 
                                                proj4string=sp::CRS(projargs="+init=epsg:2193"))
              # Return
              return(sdf)
            }

            # Function to generate unconditional simulations 
            # for a specific setseed_id using a calculated variogram
            sims_generation <- function(newsdf, fvar, points, setseed_id, loop_sim){
              # Set seed
              set.seed(setseed_id)

              # Create simulations for that set.seed (z.s means simulations of z)
              z.s <- gstat::krige(z~1, loc=NULL, newdata=newsdf, model=fvar, nmax=100, nsim=loop_sim, 
                                  beta=0, dummy=T)

              # Convert spatial dataframe to dataframe
              z.s.df <- as.data.frame(z.s)

              # Rename coordinates
              z.s.df <- z.s.df %>%
                rename(x = coords.x1, y = coords.x2)

              # Add original z column
              z.s.df <- add_column(z.s.df, z=points$z, .after=2)

              # Change columns' names      
              colnames(z.s.df)[4:length(z.s.df)] <- paste0('sim', seq(1, length(z.s.df)-3))

              # Return
              return(z.s.df)
            }

            # Function to SELECT simulations in a specific set.seed
            # that are highly simular to the empirical variogram
            selected_sims_oneseed <- function(newsdf, fvar, points, setseed_id, loop_sim,
                                              lower_range, upper_range,
                                              lower_sill, upper_sill,
                                              lower_nugget, upper_nugget){

              # Create simulations
              z.s.df <- sims_generation(newsdf, fvar, points, setseed_id, loop_sim)

              # Convert to spatial dataframe
              z.s.spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), 
                                                    data=z.s.df, 
                                                    proj4string=sp::CRS(projargs="+init=epsg:2193"))

              # Name of columns
              sim_name <- colnames(z.s.df)[4:length(colnames(z.s.df))]


              # Create fitvar for simulations of a specific set.seed
              fitvar_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))

                # Calculate fitted variogram
                fit_varr <- gstat::fit.variogram(object=gstat::variogram(object=form, locations=z.s.spf), model=gstat::vgm('Gau'))

                # Return list of range, sill, and nugget
                return(list(fit_varr$range[2], fit_varr$psill[2], fit_varr$psill[1]))
                })

              # Add to dataframe
              # Create dimensions by using matrix function
              z.fitvar.m = matrix(ncol=3, nrow=loop_sim)
              # Create fitvar dataframe
              z.fitvar.df <- as.data.frame(z.fitvar.m)
              # Create dataframe column names
              colnames(z.fitvar.df) <- c('range', 'sill', 'nugget')
              # Assign values into each columns
              z.fitvar.df$range <- unlist(fitvar_list)[seq(1, loop_sim*3, 3)]
              z.fitvar.df$sill <- unlist(fitvar_list)[seq(2, loop_sim*3, 3)]
              z.fitvar.df$nugget <- unlist(fitvar_list)[seq(3, loop_sim*3, 3)]


              # Create another column named OK
              # to check conditions for range, sill, and nugget
              z.fitvar.ok <- z.fitvar.df %>%
                                mutate(OK = (z.fitvar.df$range>=lower_range)&(z.fitvar.df$range<=upper_range)
                                            &(z.fitvar.df$sill>=lower_sill)&(z.fitvar.df$sill<=upper_sill))

              # Get indices of chosen simulations
              ind.z = which(z.fitvar.ok$OK == TRUE) + 3

              # Get lists of chosen simulations
              chosen.sims = lapply(names(z.s.df)[ind.z], function(x) z.s.df[[x]])
            }

            # Function to select simulations through many set.seeds
            selected_sims_multiseeds <- function(newsdf, fvar, points, num.seeds, loop_sim, 
                                                 range_max_rate, sill_max_rate, nugget_max_rate){

              #setup parallel backend to use many processors
              cores= detectCores()
              cl <- makeCluster(cores[1]-1) #not to overload computer
              registerDoParallel(cl)

              # Range
              upper_range = fvar$range[2]*range_max_rate
              lower_range = fvar$range[2]*(2-range_max_rate)

              # Sill
              upper_sill = fvar$psill[2]*sill_max_rate
              lower_sill = fvar$psill[2]*(2-sill_max_rate)

              # Nugget
              upper_nugget = fvar$psill[1]*nugget_max_rate
              lower_nugget = fvar$psill[1]*(2-nugget_max_rate)

              # Parallel
              sim_lists <- foreach(i=1:num.seeds, .combine=append, 
                                   .packages=c('gstat', 'sp', 'tidyverse', 'dplyr', 'tibble'),
                                   .export=c("selected_sims_oneseed", "sims_generation")) %dopar% {

                # Create a list of each time simulating
                sim_eachlist <- selected_sims_oneseed(newsdf, fvar, points, i, loop_sim,
                                                      lower_range, upper_range,
                                                      lower_sill, upper_sill,
                                                      lower_nugget, upper_nugget)

                # Return the list of simulations
                sim_eachlist
              }

              return(sim_lists)
            }

            # RUN FUNCTIONS -------------------------------------------------------
            bathy_sims <- selected_sims_multiseeds(newbathy_sdf, fit_var, bathy_points, 1, 3000,
                                                   1.1, 1.1, 1.1)


            # TRANSFORM DATA BACK -------------------------------------------------
            # Convert list of chosen sims to matrix
            bathy_sims_m = matrix(unlist(bathy_sims), 
                                  ncol=length(bathy_sims), 
                                  nrow=dim(bathy_points)[1])

            # Convert matrix to dataframe
            bathy_sims_convert = as.data.frame(bathy_sims_m)

            # Rename
            colnames(bathy_sims_convert) <- paste0('sim', seq(1, length(bathy_sims)))

            # Select columns
            bathy_sims_df <- bathy_sims_convert
            newbathy_sims_df <- bathy_sims_convert
            
            # PLOT VARIOGRAMS --------------------------------------------------
            # Function to generate list of var
            var_generation <- function(points, df){
              # Convert to spatial dataframe
              spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), data=df, proj4string=sp::CRS(projargs="+init=epsg:2193"))
              
              # Name of columns
              sim_name <- colnames(df)
            
              # Create fitvar for simulations of this seed
              var_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))
                
                varr <- gstat::variogram(object=form, locations=spf)
                
                # Return list of range, sill, and nugget
                return(varr)
                })
              var_list
            }
            
            # Function to generate fit_var
            fit_generation <- function(points, df){
              
              # Convert to spatial dataframe
              spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), data=df, proj4string=sp::CRS(projargs="+init=epsg:2193"))
              
              # Name of columns
              sim_name <- colnames(df)
            
              # Create fitvar for simulations of this seed
              fitvar_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))
                
                # Calculate fitted variogram
                fit_varr <- gstat::fit.variogram(object=gstat::variogram(object=form, locations=spf), model=gstat::vgm('Gau'))
                
                # Return list of range, sill, and nugget
                return(fit_varr)
                })
              fitvar_list
            }
            
            # Plot-many-variograms-in-one-graph function
            # Ref: https://stackoverflow.com/questions/59545834/highlighting-one-of-my-line-graphs-in-ggplot
            plot_variogram <- function(v, f, ori_v, ori_f){
              # Plot many variograms
              p <- ggplot()
              for (i in 1:length(f)){
                preds = gstat::variogramLine(f[[i]], maxdist=max(v[[i]]$dist))
                p <- p + geom_line(data=preds, aes(x=dist, y=gamma))
              }
              # Plot main vairogram
              main_preds = gstat::variogramLine(ori_f, maxdist=max(ori_v$dist))
              p + geom_line(data=main_preds, aes(x=dist, y=gamma), color='red', size=1.5)
            }
            
            # Calculate lists of var and fit_var
            v_list <- var_generation(bathy_points, bathy_sims_df)
            f_list <- fit_generation(bathy_points, bathy_sims_df)
            
            # Plot and save plot to png
            plot_sim_path = paste(bathy_analysis_path, "slope_sim_variogram.png", sep = '')
            plot_sim_var = plot_variogram(v_list, f_list, var, fit_var)
            ggsave(plot_sim_path, plot=plot_sim_var)
            
            # PLOT SIMULATED LINES --------------------------------------------------------
            # Get distance column
            copy_bathy_sims_df <- as.data.frame(bathy_sims_df)
            copy_bathy_sims_df$distance <- seq(0, by = 10, length.out = nrow(copy_bathy_sims_df))
            
            # Plot lines
            data_melt <- reshape2::melt(copy_bathy_sims_df, id='distance')
            plot_lines_path = paste(bathy_analysis_path, "slope_simulated_lines.png", sep = '')
            gfg_plot <- ggplot(data_melt,            
                               aes(x = distance,
                                   y = value,
                                   color=variable)) +  geom_line()
            
            ggsave(plot_lines_path, plot=gfg_plot)
            
            
            # PLOT ERROR AREA -----------------------------------------------------------
            # Calculate mean and standard deviation for each row
            data_mean <- apply(newbathy_sims_df, 1, mean)
            data_sd <- apply(newbathy_sims_df, 1, sd)
            
            # Create dataframe includes distance, mean, and sd
            data_error <- data.frame(
              distance=copy_bathy_sims_df$distance,
              mean=data_mean,
              sd=data_sd
            )
            
            # Plot error
            plot_error_path = paste(bathy_analysis_path, "slope_unit_error_area.png", sep = '')
            red2 <- adjustcolor("red", alpha.f=0.25)
            error_plot = f <- ggplot(
                data_error, aes(x = distance, y = mean, ymin = mean-sd, ymax = mean+sd)
                ) + xlab('distance') + ylab('Mean +/- sd') + geom_errorbar(width = 0.2, col=red2) + geom_point(size = 1.5, col='red')
            ggsave(plot_error_path, plot=error_plot)
            
            # RETURN NECESSARY DATAFRAME TO PYTHON -----------------------------------
            newbathy_sims_df
        ''')

    else: # FLOW
        # Get pandas dataframes of original para and bathy_points
        para_df, ori_error_df, bathy_points = get_r_bathypoints(para_name, .1)

        # Write out csv bathy_points
        ori_error_df.to_csv(fr"{bathy_analysis_path}\bathy_points_{para_name}.csv", index=False)

        # Attach r dataframe into r variable
        robjects.globalenv['bathy_points'] = bathy_points

        # Get simulations
        z_sim = robjects.r('''
            # Import all necessary libraries
            library(sp)
            library(gstat)
            library(ggplot2)
            library(tidyverse)
            library(dplyr)
            library(zeallot)
            library(tibble)
            library(foreach)
            library(doParallel)

            # DATA PREPARATION ------------------------------------------                   
            # Convert data to spatial data
            bathy_sdf <- sp::SpatialPointsDataFrame(coords=cbind(bathy_points$x, bathy_points$y), 
                                                    data=bathy_points, 
                                                    proj4string=sp::CRS(projargs="+init=epsg:2193"))

            # Create new data
            newbathy_df <- data.frame(bathy_points$x, bathy_points$y)
            colnames(newbathy_df)[1] <- 'x'
            colnames(newbathy_df)[2] <- 'y'
            newbathy_sdf <- sp::SpatialPointsDataFrame(coords=cbind(newbathy_df$x, newbathy_df$y), 
                                                       data=newbathy_df, 
                                                       proj4string=sp::CRS(projargs="+init=epsg:2193"))

            # EMPIRICAL VARIOGRAM ----------------------------------------
            # Calculate empirical variogram
            var <- gstat::variogram(object=z~1, locations=bathy_sdf)
            fit_var <- gstat::fit.variogram(
                object=var, fit.sills=F, fit.ranges=F,
                model=gstat::vgm(nugget=0.0000001, 'Gau', psill=0.5, range=8000)
            )
            # Plot variogram and save
            plot_ori_path = paste(bathy_analysis_path, "flow_ori_variogram.png", sep = '') # Saving path
            ori_pred = variogramLine(fit_var, maxdist = max(var$dist))  # Generate variogramline for plotting
            plot_ori_var = ggplot(var, aes(x = dist, y = gamma)) +
                                geom_point() +
                                geom_line(data = ori_pred) # Plot using ggplot
            ggsave(plot_ori_path, plot=plot_ori_var) # Save plot

            # FUNCTIONS FOR SIMULATIONS -----------------------------------
            # Function to create new spatial dataframe
            spatial_df <- function(points){
              # Convert data as necessary
              sdf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), 
                                                data=points, 
                                                proj4string=sp::CRS(projargs="+init=epsg:2193"))
              # Return
              return(sdf)
            }

            # Function to generate unconditional simulations 
            # for a specific setseed_id using a calculated variogram
            sims_generation <- function(newsdf, fvar, points, setseed_id, loop_sim){
              # Set seed
              set.seed(setseed_id)
              z.s <- gstat::krige(z~1, loc=NULL, newdata=newsdf, model=fvar, nmax=100, nsim=loop_sim, beta=0, dummy=T)  # Create simulations for that set.seed (z.s means simulations of z)

              # Convert spatial dataframe to dataframe
              z.s.df <- as.data.frame(z.s)

              # Rename coordinates
              z.s.df <- z.s.df %>%
                rename(x = coords.x1, y = coords.x2)

              # Add original z column
              z.s.df <- add_column(z.s.df, z=points$z, .after=2)

              # Calculate mean for each group of z
              z.s.dff <- z.s.df %>%
                group_by(z) %>%
                mutate(across(!x & !y, mean))

              # Change columns' names
              colnames(z.s.dff)[4:length(z.s.dff)] <- paste0('sim', seq(1, length(z.s.dff)-3))

              # Return
              return(z.s.dff)
            }

            # Function to SELECT simulations in a specific set.seed
            # that are highly simular to the empirical variogram
            selected_sims_oneseed <- function(newsdf, fvar, points, setseed_id, loop_sim,
                                              lower_range, upper_range,
                                              lower_sill, upper_sill,
                                              lower_nugget, upper_nugget){

              # Create simulations
              z.s.df <- sims_generation(newsdf, fvar, points, setseed_id, loop_sim)

              # Convert to spatial dataframe
              z.s.spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), 
                                                    data=z.s.df, 
                                                    proj4string=sp::CRS(projargs="+init=epsg:2193"))

              # Name of columns
              sim_name <- colnames(z.s.df)[4:length(colnames(z.s.df))]


              # Create fitvar for simulations of a specific set.seed
              fitvar_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))

                # Calculate fitted variogram
                fit_varr <- gstat::fit.variogram(object=gstat::variogram(object=form, locations=z.s.spf), model=gstat::vgm('Gau'))

                # Return list of range, sill, and nugget
                return(list(fit_varr$range[2], fit_varr$psill[2], fit_varr$psill[1]))
                })

              # Add to dataframe
              # Create dimensions by using matrix function
              z.fitvar.m = matrix(ncol=3, nrow=loop_sim)
              # Create fitvar dataframe
              z.fitvar.df <- as.data.frame(z.fitvar.m)
              # Create dataframe column names
              colnames(z.fitvar.df) <- c('range', 'sill', 'nugget')
              # Assign values into each columns
              z.fitvar.df$range <- unlist(fitvar_list)[seq(1, loop_sim*3, 3)]
              z.fitvar.df$sill <- unlist(fitvar_list)[seq(2, loop_sim*3, 3)]
              z.fitvar.df$nugget <- unlist(fitvar_list)[seq(3, loop_sim*3, 3)]


              # Create another column named OK
              # to check conditions for range, sill, and nugget
              z.fitvar.ok <- z.fitvar.df %>%
                                mutate(OK = (z.fitvar.df$range>=lower_range)&(z.fitvar.df$range<=upper_range)
                                            &(z.fitvar.df$sill>=lower_sill)&(z.fitvar.df$sill<=upper_sill))

              # Get indices of chosen simulations
              ind.z = which(z.fitvar.ok$OK == TRUE) + 3

              # Get lists of chosen simulations
              chosen.sims = lapply(names(z.s.df)[ind.z], function(x) z.s.df[[x]])
            }

            # Function to select simulations through many set.seeds
            selected_sims_multiseeds <- function(newsdf, fvar, points, num.seeds, loop_sim, 
                                                 range_max_rate, sill_max_rate, nugget_max_rate){

              #setup parallel backend to use many processors
              cores= detectCores()
              cl <- makeCluster(cores[1]-1) #not to overload computer
              registerDoParallel(cl)

              # Range
              upper_range = fvar$range[2]*range_max_rate
              lower_range = fvar$range[2]*(2-range_max_rate)

              # Sill
              upper_sill = fvar$psill[2]*sill_max_rate
              lower_sill = fvar$psill[2]*(2-sill_max_rate)

              # Nugget
              upper_nugget = fvar$psill[1]*nugget_max_rate
              lower_nugget = fvar$psill[1]*(2-nugget_max_rate)

              # Parallel
              sim_lists <- foreach(i=1:num.seeds, .combine=append, 
                                   .packages=c('gstat', 'sp', 'tidyverse', 'dplyr', 'tibble'),
                                   .export=c("selected_sims_oneseed", "sims_generation")) %dopar% {

                # Create a list of each time simulating
                sim_eachlist <- selected_sims_oneseed(newsdf, fvar, points, i, loop_sim,
                                                      lower_range, upper_range,
                                                      lower_sill, upper_sill,
                                                      lower_nugget, upper_nugget)

                # Return the list of simulations
                sim_eachlist
              }

              return(sim_lists)
            }

            # RUN FUNCTIONS -------------------------------------------------------
            bathy_sims <- selected_sims_multiseeds(newbathy_sdf, fit_var, bathy_points, 1, 25000,
                                                   1.1, 1.1, 1.1)


            # TRANSFORM DATA BACK -------------------------------------------------
            # Convert list of chosen sims to matrix
            bathy_sims_m = matrix(unlist(bathy_sims), 
                                  ncol=length(bathy_sims), 
                                  nrow=dim(bathy_points)[1])

            # Convert matrix to dataframe
            bathy_sims_convert = as.data.frame(bathy_sims_m)
            newbathy_sims_convert = as.data.frame(bathy_sims_m)

            # Rename
            colnames(bathy_sims_convert) <- paste0('sim', seq(1, length(bathy_sims)))
            colnames(newbathy_sims_convert) <- paste0('sim', seq(1, length(bathy_sims)))

            # Select columns
            bathy_sims_df <- bathy_sims_convert
            newbathy_sims_df <- bathy_sims_convert

            # PLOT VARIOGRAMS --------------------------------------------------
            # Function to generate list of var
            var_generation <- function(points, df){
              # Convert to spatial dataframe
              spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), data=df, proj4string=sp::CRS(projargs="+init=epsg:2193"))

              # Name of columns
              sim_name <- colnames(df)

              # Create fitvar for simulations of this seed
              var_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))

                varr <- gstat::variogram(object=form, locations=spf)

                # Return list of range, sill, and nugget
                return(varr)
                })
              var_list
            }

            # Function to generate fit_var
            fit_generation <- function(points, df){

              # Convert to spatial dataframe
              spf <- sp::SpatialPointsDataFrame(coords=cbind(points$x, points$y), data=df, proj4string=sp::CRS(projargs="+init=epsg:2193"))

              # Name of columns
              sim_name <- colnames(df)

              # Create fitvar for simulations of this seed
              fitvar_list <- lapply(sim_name, function(col){
                # Set up formula
                form <- as.formula(paste0(col, "~", 1))

                # Calculate fitted variogram
                fit_varr <- gstat::fit.variogram(object=gstat::variogram(object=form, locations=spf), model=gstat::vgm('Gau'))

                # Return list of range, sill, and nugget
                return(fit_varr)
                })
              fitvar_list
            }

            # Plot-many-variograms-in-one-graph function
            # Ref: https://stackoverflow.com/questions/59545834/highlighting-one-of-my-line-graphs-in-ggplot
            plot_variogram <- function(v, f, ori_v, ori_f){
              # Plot many variograms
              p <- ggplot()
              for (i in 1:length(f)){
                preds = gstat::variogramLine(f[[i]], maxdist=max(v[[i]]$dist))
                p <- p + geom_line(data=preds, aes(x=dist, y=gamma))
              }
              # Plot main vairogram
              main_preds = gstat::variogramLine(ori_f, maxdist=max(ori_v$dist))
              p + geom_line(data=main_preds, aes(x=dist, y=gamma), color='red', size=1.5)
            }

            # Calculate lists of var and fit_var
            v_list <- var_generation(bathy_points, bathy_sims_df)
            f_list <- fit_generation(bathy_points, bathy_sims_df)

            # Plot and save plot to png
            plot_sim_path = paste(bathy_analysis_path, "flow_variogram.png", sep = '')
            plot_sim_var = plot_variogram(v_list, f_list, var, fit_var)
            ggsave(plot_sim_path, plot=plot_sim_var)
            
            # PLOT SIMULATED LINES --------------------------------------------------------
            # Get distance column
            copy_bathy_sims_df <- as.data.frame(bathy_sims_df)
            copy_bathy_sims_df$distance <- seq(0, by = 10, length.out = nrow(copy_bathy_sims_df))
            
            # Plot lines
            data_melt <- reshape2::melt(copy_bathy_sims_df, id='distance')
            plot_lines_path = paste(bathy_analysis_path, "flow_simulated_lines.png", sep = '')
            gfg_plot <- ggplot(data_melt,            
                               aes(x = distance,
                                   y = value,
                                   color=variable)) +  geom_line()
            
            ggsave(plot_lines_path, plot=gfg_plot)
            
            # PLOT ERROR AREA -----------------------------------------------------------
            # Calculate mean and standard deviation for each row
            data_mean <- apply(newbathy_sims_df, 1, mean)
            data_sd <- apply(newbathy_sims_df, 1, sd)
            
            # Create dataframe includes distance, mean, and sd
            data_error <- data.frame(
              distance=copy_bathy_sims_df$distance,
              mean=data_mean,
              sd=data_sd
            )
            
            # Plot error
            plot_error_path = paste(bathy_analysis_path, "flow_unit_error_area.png", sep = '')
            red2 <- adjustcolor("red", alpha.f=0.25)
            error_plot = f <- ggplot(
                data_error, aes(x = distance, y = mean, ymin = mean-sd, ymax = mean+sd)
                ) + xlab('distance') + ylab('Mean +/- sd') + geom_errorbar(width = 0.2, col=red2) + geom_point(size = 1.5, col='red')
            ggsave(plot_error_path, plot=error_plot)
            
            # RETURN NECESSARY DATAFRAME TO PYTHON -----------------------------------
            newbathy_sims_df

        ''')

    # Reset indices
    errors_sd_df = z_sim.reset_index(drop=True)

    # Write out original error and original para
    para_df.to_csv(fr"{bathy_path}\\bathy_analyses\original_para_{para_name}.csv", index=False)
    ori_error_df.to_csv(fr"{bathy_path}\\bathy_analyses\\original_error_{para_name}.csv", index=False)

    # Convert errors in standard deviation into errors in meter
    multiply_param = {
        'y': ori_error_df['z']
    }
    errors_meter_df = errors_sd_df.apply(
        (lambda x, y: x*y),
        **multiply_param,
        axis=0
    )

    # Add errors in meter to the original parameter
    addition_param = {
        'y': para_df['z']
    }
    new_para_df = errors_meter_df.apply(
        (lambda x, y: x+y),
        **addition_param,
        axis=0
    )

    # Get list of columns having negative values
    negative_value_list = new_para_df.columns[(new_para_df < 0).any()].tolist()
    errors_sd_removenegative_df = errors_sd_df.drop(negative_value_list, axis=1)
    errors_meter_removenegative_df = errors_meter_df.drop(negative_value_list, axis=1)
    new_para_removenegative_df = new_para_df.drop(negative_value_list, axis=1)

    # Remove columns
    new_para_selected_df = new_para_removenegative_df[new_para_removenegative_df.columns[:50]]
    errors_sd_selected_df = errors_sd_removenegative_df[errors_sd_removenegative_df.columns[:50]]
    errors_meter_selected_df = errors_meter_removenegative_df[errors_meter_removenegative_df.columns[:50]]

    # Rename
    errors_sd_selected_df.columns = [f'sim{i}' for i in range(1, 51, 1)]
    errors_meter_selected_df.columns = [f'sim{i}' for i in range(1, 51, 1)]
    new_para_selected_df.columns = [f'sim{i}' for i in range(1, 51, 1)]

    return errors_sd_selected_df, errors_meter_selected_df, new_para_selected_df

# END GENERATE ERROR SIMULATIONS --------------------------------------------------------------------


# GENERATE SIMULATIONS OF BED ELEVATION -------------------------------------------------------------
# The depth calculation functions below used to calculate depth when chosen parameter was simulated
# with errors from variogram. There are two kind of calculations - Neal et al and Rupp and Smart. These
# functions are the same, they are only different at the order of arguments due to using *args later for
# calculate through columns faster.
#
# Four main arguments/parameters are width, slope, width, and friction (only for Neal et al)
# Functions return the depth calculated from these parameters
#
# References: https://stackoverflow.com/questions/49635436/shapely-point-geometry-in-geopandas-df-to-lat-lon-columns
# https://stackoverflow.com/questions/39142876/check-if-a-polygon-is-a-multipolygon-in-shapely

# PARAMETERS CALCULATION FOR COMBINATION ###############################################################################
def calculate_depth_nealcom(width, slope, flow, n):
    alpha = 2 / 3
    beta = 0.5
    K_0 = 1 / n
    return calculate_depth(alpha, beta, K_0, slope, width, flow)
vecneal = np.vectorize(calculate_depth_nealcom)


def calculate_depth_ruppcom(width, slope, flow):
    alpha = 0.745
    beta = 0.305
    K_0 = 6.16
    return calculate_depth(alpha, beta, K_0, slope, width, flow)
vecrupp = np.vectorize(calculate_depth_ruppcom)


# GENERATE SIMULATIONS #################################################################################3
def generate_bedsim(para_textname, kind, cmap_color='cool'):
    """
    @Definition:
                A function to generate simulations of bed elevations calculated from chosen parameter with errors
    @References:
                https://stackoverflow.com/questions/18427564/order-of-parameters-of-function-call-of-python
                https://stackoverflow.com/questions/49237663/passing-a-function-with-multiple-arguments-to-dataframe-apply
                https://stackoverflow.com/questions/38247720/python-3-5-typeerror-got-multiple-values-for-argument
                https://stackoverflow.com/questions/12182744/python-pandas-apply-a-function-with-arguments-to-a-series
                https://towardsdatascience.com/how-to-use-variable-number-of-arguments-in-python-functions-d3a49a9b7db6
                https://stackoverflow.com/questions/38247720/python-3-5-typeerror-got-multiple-values-for-argument
                https://towardsdatascience.com/args-kwargs-how-to-specify-arguments-correctly-ed995f3f3c05
                https://stackoverflow.com/questions/12182744/python-pandas-apply-a-function-with-arguments-to-a-series
                https://stackoverflow.com/questions/74097131/pandas-assign-across-multiple-columns-functionally
                https://stackoverflow.com/questions/65860419/pandas-equivalent-to-mutate-accros (assign is similar to mutate)
                (Similar to mutate and across for python) https://stackoverflow.com/questions/57348289/equivalent-of-mutate-at-dplyr-function-in-python-pandas
    @Arguments:
                para_textname (string):
                                Name of parameter that needs to simulated. This is different from the para_name
                                above, they are only 'width', 'slope', 'flow', and 'friction'
                kind (string):
                                'neal' - Neal's formula
                                'rupp' - Rupp and Smart's formula
                cmap_color (string):
                                Name of color
    @Returns:
                bed_sims_df (pandas dataframe):
                                    Dataframe that includes all simulations of bed elevations calculated from chosen
                                    parameter with errors
    """
    # Choose kind of formula - Neal et al
    if kind == 'neal':
        # Calculate water surface elevation
        wse = river_bathymetry['flood_depth_Neal_et_al'] + river_bathymetry['bed_elevation_Neal_et_al']

        # Calculate depth with width errors
        if para_textname == 'width':
            # Get error in sd, error in meter, and width simulations
            err_sd_df, err_meter_df, para_df = generate_parasim(width_name)

            # Get all paras for calculating depth calculation
            depth_param = {'slope': river_characteristics[slope_name],
                           'flow': river_characteristics[flow_name],
                           'friction': river_characteristics[friction_name]}

            # Get depth simulations
            depth_df = para_df.apply(
                (lambda width, slope, flow, friction: calculate_depth(2/3, 0.5, 1/friction, slope, width, flow)),
                **depth_param, axis=0)

        # Calculate depth with slope errors
        elif para_textname == 'slope':
            # Get error in sd, error in meter, and slope simulations
            err_sd_df, err_meter_df, para_df = generate_parasim(slope_name)

            # Get all paras for calculating depth calculation
            depth_param = {'width': river_characteristics[width_name],
                           'flow': river_characteristics[flow_name],
                           'friction': river_characteristics[friction_name]}

            # Get depth simulations
            depth_df = para_df.apply(
                (lambda slope, width, flow, friction: calculate_depth(2 / 3, 0.5, 1 / friction, slope, width, flow)),
                **depth_param, axis=0)

        # Calculate depth with flow errors
        else:
            # Get error in sd, error in meter, and slope simulations
            err_sd_df, err_meter_df, para_df = generate_parasim(flow_name)

            # Get all paras for depth calculation
            depth_param = {'width': river_characteristics[width_name],
                           'slope': river_characteristics[slope_name],
                           'friction': river_characteristics[friction_name]}

            # Get depth simulations
            depth_df = para_df.apply(
                (lambda flow, width, slope, friction: calculate_depth(2 / 3, 0.5, 1 / friction, slope, width, flow)),
                **depth_param, axis=0)

    # Choose kind of formula - Rupp and Smart
    else:
        # Calculate water surface elevation
        wse = river_bathymetry['flood_depth_Rupp_and_Smart'] + river_bathymetry['bed_elevation_Rupp_and_Smart']

        # Calculate depth with width errors
        if para_textname == 'width':
            # Get error in sd, error in meter, and width simulations
            err_sd_df, err_meter_df, para_df = generate_parasim(width_name)

            # Get all paras for calculating depth calculation
            depth_param = {'slope': river_characteristics[slope_name],
                           'flow': river_characteristics[flow_name]}

            # Get depth simulations
            depth_df = para_df.apply(
                (lambda width, slope, flow: calculate_depth(0.745, 0.305, 6.16, slope, width, flow)),
                **depth_param, axis=0)

        # Calculate depth with slope errors
        elif para_textname == 'slope':
            # Get error in sd, error in meter, and slope simulations
            err_sd_df, err_meter_df, para_df = generate_parasim(slope_name)

            # Get all paras for calculating depth calculation
            depth_param = {'width': river_characteristics[width_name],
                           'flow': river_characteristics[flow_name]}

            # Get depth simulations
            depth_df = para_df.apply(
                (lambda slope, width, flow: calculate_depth(0.745, 0.305, 6.16, slope, width, flow)),
                **depth_param, axis=0)

        # Calculate depth with flow errors
        else:
            # Get error in sd, error in meter, and slope simulations
            err_sd_df, err_meter_df, para_df = generate_parasim(flow_name)

            # Get all paras for depth calculation
            depth_param = {'width': river_characteristics[width_name],
                           'slope': river_characteristics[slope_name]}

            # Get depth simulations
            depth_df = para_df.apply(
                (lambda flow, width, slope: calculate_depth(0.745, 0.305, 6.16, slope, width, flow)),
                **depth_param, axis=0)
    
    # Calculate simulations of bed elevation
    bed_df = (depth_df * -1).add(wse, axis=0)

    # # Write out river_bathymetry dataframes
    # copy_river_bathymetry = river_bathymetry.copy(deep=True)
    # for column in bed_df:
    #     # Get filename
    #     filename = column + "_" + para_textname + "_" + kind
    #     # Copy all necessary files into a simulated folder
    #     copy_geom([51559, 50554], filename)
    #
    #     # Create necessary files for bathymetry
    #     if kind == 'neal':
    #         copy_river_bathymetry['bed_elevation_Neal_et_al'] = bed_df[column]
    #         copy_river_bathymetry = copy_river_bathymetry.to_crs(2193)
    #         copy_river_bathymetry.to_file(fr"{bathy_path}\\bathy_{filename}\\river_bathymetry.geojson",
    #                                       crs=2193, driver='GeoJSON')
    #
    #     else:
    #         copy_river_bathymetry['bed_elevation_Rupp_and_Smart'] = bed_df[column]
    #         copy_river_bathymetry = copy_river_bathymetry.to_crs(2193)
    #         copy_river_bathymetry.to_file(fr"{bathy_path}\\bathy_{filename}\\river_bathymetry.geojson",
    #                                       crs=2193, driver='GeoJSON')

    # Write out all simulations into csv files
    # Coords
    coord_dict = {
        'x': river_characteristics.geometry.x,
        'y': river_characteristics.geometry.y
    }
    coord_df = pd.DataFrame(data=coord_dict)
    coord_df.insert(0, 'distance', range(0, 10 * len(coord_df), 10)) # Calculate distance
    coord_df.to_csv(fr"{bathy_path}\\bathy_analyses\\coord_{para_textname}_{kind}.csv", index=False)
    # Error in sd
    err_sd_df.to_csv(fr"{bathy_path}\\bathy_analyses\\err_sd_{para_textname}_{kind}.csv", index=False)
    # Error in meter
    err_meter_df.to_csv(fr"{bathy_path}\\bathy_analyses\\err_meter_{para_textname}_{kind}.csv", index=False)
    # Para
    para_df.to_csv(fr"{bathy_path}\\bathy_analyses\\para_{para_textname}_{kind}.csv", index=False)
    # Depth
    depth_df.to_csv(fr"{bathy_path}\\bathy_analyses\\depth_{para_textname}_{kind}.csv", index=False)
    # Bed elevation
    bed_df.to_csv(fr"{bathy_path}\\bathy_analyses\\bed_{para_textname}_{kind}.csv", index=False)
    # Original depth and bed
    para_name = {
        'width': width_name,
        'slope': slope_name,
        'flow': flow_name
    }
    ori_depth_bed_wse_dict = {
        'para': river_characteristics[para_name[para_textname]],
        'depth': river_bathymetry['flood_depth_Neal_et_al'] if kind=='neal' else river_bathymetry['flood_depth_Rupp_and_Smart'],
        'bed': river_bathymetry['bed_elevation_Neal_et_al'] if kind=='neal' else river_bathymetry['bed_elevation_Rupp_and_Smart'],
        'wse': river_bathymetry['bed_elevation_Neal_et_al'] + river_bathymetry['flood_depth_Neal_et_al'] if kind=='neal' else river_bathymetry['bed_elevation_Rupp_and_Smart'] + river_bathymetry['flood_depth_Rupp_and_Smart']
    }
    ori_depth_bed_wse_df = pd.DataFrame(data=ori_depth_bed_wse_dict)
    ori_depth_bed_wse_df.to_csv(fr"{bathy_path}\\bathy_analyses\\ori_depth_bed_wse.csv", index=False)

    # Calculate statistics for error
    err_meter_copy_df = err_meter_df.copy(deep=True)
    err_meter_copy_df['mean'] = err_meter_df.mean(axis=1)
    err_meter_copy_df['sd'] = err_meter_df.std(axis=1)
    err_meter_copy_df['cv'] = err_meter_df.std(axis=1) / err_meter_df.mean(axis=1)
    err_meter_copy_df['max'] = err_meter_df.max(axis=1)
    err_meter_copy_df['min'] = err_meter_df.min(axis=1)

    # Calculate statistics for para
    para_copy_df = para_df.copy(deep=True)
    para_copy_df['mean'] = para_df.mean(axis=1)
    para_copy_df['sd'] = para_df.std(axis=1)
    para_copy_df['cv'] = para_df.std(axis=1) / para_df.mean(axis=1)
    para_copy_df['min'] = para_df.min(axis=1)
    para_copy_df['max'] = para_df.max(axis=1)

    # Calculate statistics for depth
    depth_copy_df = depth_df.copy(deep=True)
    depth_copy_df['mean'] = depth_df.mean(axis=1)
    depth_copy_df['sd'] = depth_df.std(axis=1)
    depth_copy_df['cv'] = depth_df.std(axis=1) / depth_df.mean(axis=1)
    depth_copy_df['min'] = depth_df.min(axis=1)
    depth_copy_df['max'] = depth_df.max(axis=1)

    # Calculate statistic for bed elevation
    bed_copy_df = bed_df.copy(deep=True)
    bed_copy_df['mean'] = bed_df.mean(axis=1)
    bed_copy_df['sd'] = bed_df.std(axis=1)
    bed_copy_df['cv'] = bed_df.std(axis=1) / bed_df.mean(axis=1)
    bed_copy_df['max'] = bed_df.max(axis=1)
    bed_copy_df['min'] = bed_df.min(axis=1)

    return bed_df

#######################################################################################################################


# GENERATE COMBINATION OF PARAMETERS ERRORS AND THEN BED ELEVATION ###################################################
def generate_bedsim_combination(kind, cmap_color='cool'):
    """
    @Definition:
                A function to generate simulations of bed elevations calculated from all parameters with errors
    @References:
                https://stackoverflow.com/questions/18427564/order-of-parameters-of-function-call-of-python
                https://stackoverflow.com/questions/49237663/passing-a-function-with-multiple-arguments-to-dataframe-apply
                https://stackoverflow.com/questions/38247720/python-3-5-typeerror-got-multiple-values-for-argument
                https://stackoverflow.com/questions/12182744/python-pandas-apply-a-function-with-arguments-to-a-series
                https://towardsdatascience.com/how-to-use-variable-number-of-arguments-in-python-functions-d3a49a9b7db6
                https://stackoverflow.com/questions/38247720/python-3-5-typeerror-got-multiple-values-for-argument
                https://towardsdatascience.com/args-kwargs-how-to-specify-arguments-correctly-ed995f3f3c05
                https://stackoverflow.com/questions/12182744/python-pandas-apply-a-function-with-arguments-to-a-series
                https://stackoverflow.com/questions/74097131/pandas-assign-across-multiple-columns-functionally
                https://stackoverflow.com/questions/65860419/pandas-equivalent-to-mutate-accros (assign is similar to mutate)
                (Similar to mutate and across for python) https://stackoverflow.com/questions/57348289/equivalent-of-mutate-at-dplyr-function-in-python-pandas
    @Arguments:
                para_textname (string):
                                Name of parameter that needs to simulated. This is different from the para_name
                                above, they are only 'width', 'slope', 'flow', and 'friction'
                kind (string):
                                'neal' - Neal's formula
                                'rupp' - Rupp and Smart's formula
                cmap_color (string):
                                Name of color
    @Returns:
                bed_sims_df (pandas dataframe):
                                    Dataframe that includes all simulations of bed elevations calculated from chosen
                                    parameter with errors
    """
    # Here para_textname is combination
    para_textname = 'combination'

    # Choose kind of formula - Neal et al
    if kind == 'neal':
        # Get simulations of parameters
        err_sd_width_df, err_meter_width_df, width_df = generate_parasim(width_name) # Width
        err_sd_slope_df, err_meter_slope_df, slope_df = generate_parasim(slope_name) # Slope
        err_sd_flow_df, err_meter_flow_df, flow_df = generate_parasim(flow_name) # Flow
        # Create friction dataframe
        friction_data = {}
        for i in range(1, 51, 1):
            friction_data[f'sim{i}'] = river_characteristics[friction_name]
        friction_df = pd.DataFrame(data=friction_data)

        # Calculate depth
        depth_df = pd.DataFrame(vecneal(width_df, slope_df, flow_df, friction_df))

        # Rename columns of depth
        depth_df.columns = [f'sim{colname}' for colname in range(1, 51, 1)]

        # Calculate water surface elevation
        wse = river_bathymetry['flood_depth_Neal_et_al'] + river_bathymetry['bed_elevation_Neal_et_al']

    # Choose kind of formula - Rupp and Smart
    else:
        # Get simulations of parameters
        err_sd_width_df, err_meter_width_df, width_df = generate_parasim(width_name) # Width
        err_sd_slope_df, err_meter_slope_df, slope_df = generate_parasim(slope_name) # Slope
        err_sd_flow_df, err_meter_flow_df, flow_df = generate_parasim(flow_name) # Flow

        # Calculate depth
        depth_df = pd.DataFrame(vecrupp(width_df, slope_df, flow_df))

        # Rename columns of depth
        depth_df.columns = [f'sim{colname}' for colname in range(1, 51, 1)]

        # Calculate water surface elevation
        wse = river_bathymetry['flood_depth_Rupp_and_Smart'] + river_bathymetry['bed_elevation_Rupp_and_Smart']

    # Calculate simulations of bed elevation
    bed_df = (depth_df * -1).add(wse, axis=0)

    # Rename columns
    bed_df.columns = [f'sim{colname}' for colname in range(1, 51, 1)]

    # Write out river_bathymetry dataframes
    copy_river_bathymetry = river_bathymetry.copy(deep=True)
    for column in bed_df:
        # Get filename
        filename = column + "_" + para_textname + "_" + kind
        # Copy all necessary files into a simulated folder
        copy_geom([51559, 50554], filename)

        # Create necessary files for bathymetry
        if kind == 'neal':
            copy_river_bathymetry['bed_elevation_Neal_et_al'] = bed_df[column]
            copy_river_bathymetry = copy_river_bathymetry.to_crs(2193)
            copy_river_bathymetry.to_file(fr"{bathy_path}\\bathy_{filename}\\river_bathymetry.geojson",
                                          crs=2193, driver='GeoJSON')

        else:
            copy_river_bathymetry['bed_elevation_Rupp_and_Smart'] = bed_df[column]
            copy_river_bathymetry = copy_river_bathymetry.to_crs(2193)
            copy_river_bathymetry.to_file(fr"{bathy_path}\\bathy_{filename}\\river_bathymetry.geojson",
                                          crs=2193, driver='GeoJSON')

    # Write out all simulations into csv files
    # Coords
    coord_dict = {
        'x': river_characteristics.geometry.x,
        'y': river_characteristics.geometry.y
    }
    coord_df = pd.DataFrame(data=coord_dict)
    coord_df.insert(0, 'distance', range(0, 10 * len(coord_df), 10))  # Calculate distance
    coord_df.to_csv(fr"{bathy_path}\\bathy_analyses\\coord_{para_textname}_{kind}.csv", index=False)
    # Error in sd
    err_sd_width_df.to_csv(fr"{bathy_path}\\bathy_analyses\\error_sd_width_{kind}.csv", index=False)
    err_sd_slope_df.to_csv(fr"{bathy_path}\\bathy_analyses\\error_sd_slope_{kind}.csv", index=False)
    err_sd_flow_df.to_csv(fr"{bathy_path}\\bathy_analyses\\error_sd_flow_{kind}.csv", index=False)
    # Error in meter
    err_meter_width_df.to_csv(fr"{bathy_path}\\bathy_analyses\\error_meter_width_{kind}.csv", index=False)
    err_meter_slope_df.to_csv(fr"{bathy_path}\\bathy_analyses\\error_meter_slope_{kind}.csv", index=False)
    err_meter_flow_df.to_csv(fr"{bathy_path}\\bathy_analyses\\error_meter_flow_{kind}.csv", index=False)
    # Para
    width_df.to_csv(fr"{bathy_path}\\bathy_analyses\\para_width_{kind}.csv", index=False)
    slope_df.to_csv(fr"{bathy_path}\bathy_analyses\\para_slope_{kind}.csv", index=False)
    flow_df.to_csv(fr"{bathy_path}\bathy_analyses\\para_flow_{kind}.csv", index=False)
    # Depth
    depth_df.to_csv(fr"{bathy_path}\\bathy_analyses\\depth_{para_textname}_{kind}.csv", index=False)
    # Bed elevation
    bed_df.to_csv(fr"{bathy_path}\\bathy_analyses\\bed_{para_textname}_{kind}.csv", index=False)
    # Original depth and bed
    ori_depth_bed_wse_dict = {
        'width': river_characteristics[width_name],
        'slope': river_characteristics[slope_name],
        'flow': river_characteristics[flow_name],
        'depth': river_bathymetry['flood_depth_Neal_et_al'] if kind == 'neal' else river_bathymetry[
            'flood_depth_Rupp_and_Smart'],
        'bed': river_bathymetry['bed_elevation_Neal_et_al'] if kind == 'neal' else river_bathymetry[
            'bed_elevation_Rupp_and_Smart'],
        'wse': river_bathymetry['bed_elevation_Neal_et_al'] + river_bathymetry[
            'flood_depth_Neal_et_al'] if kind == 'neal' else river_bathymetry['bed_elevation_Rupp_and_Smart'] +
                                                             river_bathymetry['flood_depth_Rupp_and_Smart']
    }
    ori_depth_bed_wse_df = pd.DataFrame(data=ori_depth_bed_wse_dict)
    ori_depth_bed_wse_df.to_csv(fr"{bathy_path}\\bathy_analyses\\ori_depth_bed_wse.csv", index=False)

    # Calculate statistics for para
    # Width
    width_copy_df = width_df.copy(deep=True)
    width_copy_df['mean'] = width_df.mean(axis=1)
    width_copy_df['sd'] = width_df.std(axis=1)
    width_copy_df['cv'] = width_df.std(axis=1) / width_df.mean(axis=1)
    width_copy_df['min'] = width_df.min(axis=1)
    width_copy_df['max'] = width_df.max(axis=1)
    # Slope
    slope_copy_df = slope_df.copy(deep=True)
    slope_copy_df['mean'] = slope_df.mean(axis=1)
    slope_copy_df['sd'] = slope_df.std(axis=1)
    slope_copy_df['cv'] = slope_df.std(axis=1) / slope_df.mean(axis=1)
    slope_copy_df['min'] = slope_df.min(axis=1)
    slope_copy_df['max'] = slope_df.max(axis=1)
    # Flow
    flow_copy_df = flow_df.copy(deep=True)
    flow_copy_df['mean'] = flow_df.mean(axis=1)
    flow_copy_df['sd'] = flow_df.std(axis=1)
    flow_copy_df['cv'] = flow_df.std(axis=1) / flow_df.mean(axis=1)
    flow_copy_df['min'] = flow_df.min(axis=1)
    flow_copy_df['max'] = flow_df.max(axis=1)

    # Calculate statistics for depth
    depth_copy_df = depth_df.copy(deep=True)
    depth_copy_df['mean'] = depth_df.mean(axis=1)
    depth_copy_df['sd'] = depth_df.std(axis=1)
    depth_copy_df['cv'] = depth_df.std(axis=1) / depth_df.mean(axis=1)
    depth_copy_df['min'] = depth_df.min(axis=1)
    depth_copy_df['max'] = depth_df.max(axis=1)

    return bed_df

# END GENERATE SIMULATIONS OF BED ELEVATION ---------------------------------------------------------