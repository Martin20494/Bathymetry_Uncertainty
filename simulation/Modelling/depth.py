# Prepare packages -----------------------------------------------------------------------------
from folder import *

import pathlib
import glob

import geopandas as gpd
import pandas as pd
import numpy as np

# ---------------------------------------------------------------------------------------------


# Variables and parameters below are set up based on Rose codes
# Ref: https://github.com/rosepearson/GeoFabrics/blob/main/src/geofabrics/processor.py

# SETTING UP VARIABLES FROM ROSE CODES --------------------------------------------------------
# Main file paths
cache_path = pathlib.Path(fr"{original_lidar_path}\\no_padding")
flow_path = pathlib.Path(original_lidar_path)

# File names generated by geofabrics
river_characteristics = gpd.read_file(cache_path / "river_characteristics.geojson")
river_bathymetry = gpd.read_file(cache_path / "river_bathymetry.geojson")
channel_name = [
    pathlib.Path(i).stem for i in glob.glob(fr"{cache_path}\\*.geojson") if pathlib.Path(i).stem.startswith("rec_channel")
][0]
channel = gpd.read_file(cache_path / fr"{channel_name}.geojson")
flow_and_friction = pd.read_csv(flow_path / "flow_and_friction.csv.gz")

# Variable names
flow_name = "flow"
friction_name = "mannings_n"

slope_name = "slope_mean_2.0km"
min_z_name = "min_z_centre_unimodal"
width_name = "widths_mean_0.25km"
flat_width_name = "flat_widths_mean_0.25km"
threshold_name = "thresholds_mean_0.25km"

# Match the river characteristics to the REC flow and frictions
# Match each channel midpoint to a nzsegment ID - based on what channel reach is closest
river_characteristics["nzsegment"] = (
        np.ones(len(river_characteristics["widths"]), dtype=float) * np.nan
)
for i, row in river_characteristics.iterrows():
    if row.geometry is not None and not row.geometry.is_empty:
        # Calculate the distance between the point from points of river_characteristics to channel
        distances = channel.distance(river_characteristics.loc[i].geometry)
        # Choose the closest distances and then choose the minimum nzsegment
        river_characteristics.loc[i, ("nzsegment")] = channel[
            distances == distances.min()
            ]["nzsegment"].min()

# Fill in any missing values
river_characteristics["nzsegment"] = (
    river_characteristics["nzsegment"].fillna(method="ffill").fillna(method="bfill")
)
river_characteristics["nzsegment"] = river_characteristics["nzsegment"].astype("int")

# Add the friction and flow values to the widths and slopes
river_characteristics[friction_name] = np.zeros(len(river_characteristics["nzsegment"]), dtype=int)
river_characteristics[flow_name] = np.zeros(len(river_characteristics["nzsegment"]), dtype=int)

for nzsegment in river_characteristics["nzsegment"].unique():
    river_characteristics.loc[
        river_characteristics["nzsegment"] == nzsegment, (friction_name)
    ] = flow_and_friction[flow_and_friction["nzsegment"] == nzsegment]["n"].unique()[0]
    river_characteristics.loc[river_characteristics["nzsegment"] == nzsegment, (flow_name)] = flow_and_friction[
        flow_and_friction["nzsegment"] == nzsegment
        ][flow_name].unique()[0]


# END SETTING UP VARIABLES FROM ROSE CODES ----------------------------------------------------

# Functions below is to calculate depth according Neal et al or Rupp et al as papers below
# Neal: https://doi.org/10.1029/2020WR028301
# Rupp: http://dx.doi.org/10.1016/j.jhydrol.2007.08.024
# For more information about functions: https://github.com/rosepearson/GeoFabrics/blob/main/src/geofabrics/processor.py

# DEPTH CALCULATION ------------------------------------------------------------------------
def calculate_depth(alpha, beta, K_0, slope, width, flow):
    full_bank_depth = ( flow / (K_0 * width * (slope ** beta) ) ) ** (1 / (1 + alpha))
    return full_bank_depth

def calculate_neal_et_al(slope, width, flow, n):
    alpha = 2/3
    beta = 0.5
    K_0 = 1/n
    return calculate_depth(alpha, beta, K_0, slope, width, flow)

def calculate_neal_et_al_expo(expo, expo_value, slope, width, flow, n):
    if expo == 'beta':
        alpha = 2/3
        K_0 = 1/n
        return calculate_depth(alpha, expo_value, K_0, slope, width, flow)
    else:
        beta = 1/2
        K_0 = 1/n

        return calculate_depth(expo_value, beta, K_0, slope, width, flow)

def calculate_rupp_et_al(slope, width, flow):
    alpha = 0.745
    beta = 0.305
    K_0 = 6.16
    return calculate_depth(alpha, beta, K_0, slope, width, flow)
# END DEPTH CALCULATION -----------------------------------------------------------------------------------------





